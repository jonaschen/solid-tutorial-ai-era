### 第八章：思考及程式練習題

#### 引言：從知道到做到的橋樑
歡迎來到這份文件的最後一章。理論的學習是地基，而實踐則是建造高樓的過程。本章提供了一系列綜合性的挑戰，旨在幫助您將前述所有 SOLID 原則融會貫通，應用於解決更貼近真實世界的複雜問題。

強烈建議您在閱讀每個問題後，先停下來，嘗試自己思考或動手解決，形成自己的答案，然後再與後面的解答與思路進行比對。這個主動思考的過程，遠比直接看答案更有價值。

---

### 第一部分：設計思考題

#### 問題 1 (SRP & ISP): 線上課程平台的模組設計
* **情境：**
    您正在設計一個線上課程平台的「課程」核心模組。圍繞著「課程」這個實體，有三種不同的角色（Actor）：
    1.  **學生 (Student):** 可以「觀看」課程影片、「查詢」課程介紹、「發表」評論。
    2.  **老師 (Teacher):** 可以「上傳」新的課程影片、「修改」課程介紹、「查看」學生的評論。
    3.  **營運人員 (Operator):** 需要「查詢」課程的總報名人數和累計銷售額，以製作財務報表。

* **挑戰：**
    如果將所有功能都塞進一個巨大的 `Course` 類別，它將很快變得難以維護。您會如何設計相關的類別與介面，來滿足不同角色的需求，並同時遵循單一職責原則 (SRP) 和介面隔離原則 (ISP)？請描述您會建立哪些類別/介面，以及它們各自的職責。

#### 問題 2 (OCP & LSP): 折扣計算引擎的擴充
* **情境：**
    您正在為一個電商網站設計一個折扣計算引擎。目前支援兩種折扣策略：
    1.  **百分比折扣** (例如，商品打九折)。
    2.  **固定金額折抵** (例如，訂單總額減 100 元)。

    現在，產品經理提出了新的需求，未來需要能輕易地增加新的折扣方式，例如：
    * **滿額贈品** (訂單滿 2000 元，贈送一個特定商品)。
    * **紅利點數折抵** (使用會員的紅利點數，每 10 點折抵 1 元)。

* **挑戰：**
    1.  請設計一個符合開放封閉原則 (OCP) 的架構，讓未來新增任何折扣策略時，都無需修改既有的核心計算邏輯。
    2.  假設「紅利點數折抵」策略有一個特殊規則：「如果用戶點數不足，則此折扣不生效，且**不能**拋出異常，必須讓後續的其他折扣能繼續計算」。這個規則對您的設計有什麼影響？您需要如何設計以確保它不違反里氏替換原則 (LSP)？

#### 問題 3 (DIP & Testability): 使用者註冊服務的重構
* **情境：**
    您看到一段既有的使用者註冊服務程式碼，其邏輯大致如下：
    ```python
    class RegistrationService:
        def register_user(self, username, password, phone_number):
            # 1. 檢查使用者名稱是否已存在 (省略)
            # 2. 發送驗證碼 (錯誤：直接依賴了具體的簡訊 API 客戶端)
            verification_code = SmsApiClient.generate_code()
            try:
                SmsApiClient.send_code(phone_number, verification_code)
            except ConnectionError:
                print("驗證碼發送失敗，註冊終止。")
                return False
            # 3. 建立使用者帳號 (省略)
            return True
    ```
* **挑戰：**
    1.  這個設計在**單元測試**上有什麼困難？特別是，您如何能輕易地測試「當驗證碼發送失敗時，註冊流程應終止」這個重要的邏輯分支？
    2.  請描述您將如何使用依賴反轉原則 (DIP) 來重構此服務。
    3.  重構後，請描述您的單元測試將如何撰寫，來說明測試性得到了提升。

#### 問題 4 (ISP & DIP): 設計一個多功能硬體加速卡驅動介面
* **情境：**
    您正在為一款新型的「加密加速卡」撰寫 Linux 驅動程式。這款硬體卡提供兩種截然不同的功能：
    1.  **大量資料加解密:** 透過一個 DMA 通道，可以高效地對大塊記憶體進行 AES 加密或解密。這是一個需要設定金鑰、模式等參數的複雜操作。
    2.  **硬體亂數生成:** 卡上內建了一個高品質的硬體亂數產生器 (TRNG)，可以作為 `/dev/hwrng` 來使用。這是一個相對簡單的唯讀操作。

* **挑戰：**
    如果將這兩種功能都透過同一個字元設備 `/dev/crypto_card` 和一套複雜的 `ioctl` 命令來暴露給使用者空間，那麼任何只想使用其中一個功能的應用程式，都必須理解整個複雜的介面，這顯然不理想。
    請應用介面隔離原則 (ISP) 和依賴反轉原則 (DIP) 的思想，設計一個更清晰、更解耦合的架構。你可能會建立幾個字元設備？你會如何定義它們各自的 `file_operations` 結構？這個驅動的內部模組又該如何劃分？

---

### 第二部分：程式重構題

#### 練習 1：重構「上帝物件」 (Refactoring a "God Object")

* **提供程式碼：**
    以下是一個違反了多個 SOLID 原則的 `ReportGenerator` 類別。
    ```python
    import sqlite3
    
    class ReportGenerator:
        def __init__(self, db_path: str):
            self.db_path = db_path
            self.conn = None

        def generate_sales_report(self, start_date, end_date):
            # 職責一：資料庫操作
            self.conn = sqlite3.connect(self.db_path)
            cursor = self.conn.cursor()
            query = "SELECT product, SUM(amount) FROM sales WHERE date BETWEEN ? AND ? GROUP BY product"
            sales_data = cursor.execute(query, (start_date, end_date)).fetchall()
            self.conn.close()
            
            # 職責二：業務邏輯計算
            total_sales = sum(row[1] for row in sales_data)
            
            # 職責三：格式化輸出 (HTML)
            html = "<html><body><h1>Sales Report</h1>"
            html += f"<h2>Total Sales: ${total_sales}</h2>"
            html += "<table border='1'><tr><th>Product</th><th>Amount</th></tr>"
            for row in sales_data:
                html += f"<tr><td>{row[0]}</td><td>${row[1]}</td></tr>"
            html += "</table></body></html>"

            # 職責四：檔案寫入
            with open("sales_report.html", "w") as f:
                f.write(html)
            print("報告已生成: sales_report.html")

    ```
* **任務：**
    請遵循 SOLID 原則（特別是 SRP 和 DIP），將這個巨大的類別重構為多個職責單一、低耦合的類別。

#### 練習 2：打造插件系統 (Building a Plugin System)

* **情境：**
    您需要開發一個簡單的文字檔處理工具。它的核心功能是讀取一個文字檔的內容。您希望讓這個工具變得可擴展，讓其他開發者可以輕鬆地為它撰寫新的「分析」功能插件。

* **任務：**
    請使用 Python 設計一個符合 OCP 和 DIP 的插件系統。
    1.  設計一個抽象的 `ITextPlugin` 介面。它應該有一個 `analyze(text: str) -> str` 方法。
    2.  建立一個主程式 `TextAnalyzer`，它可以註冊多個插件。
    3.  實作至少兩個具體的插件，例如 `WordCountPlugin` 和 `LineCountPlugin`。
    4.  您的設計必須能達到：當未來要新增第三個插件時，**完全不需要修改 `TextAnalyzer` 的任何程式碼**。

#### 練習 3：重構混雜的硬體狀態輪詢函式
* **提供程式碼：**
    以下是一段典型的嵌入式或驅動程式中的狀態輪詢 C 程式碼。
    ```c
    #include <stdio.h>
    #include <stdint.h>

    typedef struct { uint32_t status_reg; } device_t;
    #define DATA_READY (1 << 0)
    #define ERROR_FLAG (1 << 1)
    #define TEMP_WARN  (1 << 2)

    void process_incoming_data(device_t* dev) { printf("處理資料...\n"); }
    void log_error_and_reset(device_t* dev) { printf("紀錄錯誤並重設設備...\n"); }
    void adjust_fan_speed(device_t* dev) { printf("調整風扇速度...\n"); }

    void poll_device_status(device_t* dev) {
        uint32_t status = dev->status_reg;
        if (status & DATA_READY) { process_incoming_data(dev); }
        if (status & ERROR_FLAG) { log_error_and_reset(dev); }
        if (status & TEMP_WARN) { adjust_fan_speed(dev); }
    }
    ```
* **任務：**
    `poll_device_status` 函式違反了 SRP 和 OCP。請對其進行重構，目標是：
    1.  讓每個狀態的處理邏輯分離 (SRP)。
    2.  設計一個可擴充的結構，讓未來新增狀態處理時，無需修改核心的輪詢迴圈 (OCP & DIP)。

---

### 第三部分：解答與思路提示

*（注意：請在自己完成挑戰後再參考此部分）*

<details>
<summary>點此展開解答與分析</summary>

#### **思考題 1 解答 (SRP & ISP)**
* **思路提示：** 從「角色」出發，思考每個角色關心的「職責」是什麼，然後為這些職責建立專屬的服務與介面。
* **解答與分析：**
    一個好的設計是將職責分離到不同的服務類別，並定義精細的介面。
    1.  **SRP 應用：**
        * `CourseContentService`: 負責課程內容管理（`get_video`, `upload_video`）。
        * `CourseInteractionService`: 負責課程互動功能（`get_comments`, `post_comment`）。
        * `CourseAnalyticsService`: 負責課程數據分析（`get_enrollment_count`）。
    2.  **ISP 應用：**
        為不同的客戶端定義更精細的介面。
        * `IStudentCourseView` (for Student): 介面只包含 `get_video`, `get_description`, `get_comments`, `post_comment`。
        * `ITeacherCourseAdmin` (for Teacher): 介面包含 `upload_video`, `update_description`, `get_comments`。
    * **設計思考過程：** 我們沒有建立一個巨大的 `Course` 類別，而是首先根據 SRP 將相關操作聚合到不同的服務中。接著，我們從客戶端（角色）的視角出發，使用 ISP 定義了它們真正需要的最小介面集。

#### **思考題 2 解答 (OCP & LSP)**
* **思路提示：** 看到 `if/elif` 處理不同「類型」的邏輯，就要想到使用「策略模式」來實現 OCP。思考 LSP 時，要關注子類別的行為是否會讓客戶端「驚訝」。
* **解答與分析：**
    1.  **OCP 設計：**
        * 定義一個抽象的 `IDiscountStrategy` 介面，其中有一個 `apply(order)` 方法。
        * 建立 `PercentageDiscount`, `FixedAmountDiscount` 等具體的策略類別。
        * 折扣計算引擎的核心邏輯，是接收一個 `IDiscountStrategy` 的列表，然後依序呼叫它們的 `apply` 方法。
    2.  **LSP 考量：**
        * 「紅利點數不足時不生效且不拋異常」的規則，是在定義 `PointsDiscount` 的**後置條件**。
        * 為了不違反 LSP，`IDiscountStrategy` 的 `apply` 方法契約必須足夠通用。例如，可以定義其回傳一個 `DiscountResult` 物件，該物件包含「折扣是否成功應用」及「折扣金額」。`PointsDiscount` 在點數不足時，可以回傳一個「折扣未成功應用」的結果。這樣，客戶端可以根據回傳結果來決定後續行為，而不會因為某個子類別的特殊行為（如拋出預期之外的異常）而崩潰。

#### **思考題 3 解答 (DIP & Testability)**
* **思路提示：** 只要看到 `new` 一個具體類別，或呼叫一個靜態方法，就要警覺 DIP 被違反。解法是引入抽象，並透過外部注入。
* **解答與分析：**
    1.  **測試困難點：** 要測試「發送失敗」的分支，必須透過複雜的方式來讓 `SmsApiClient.send_code` 真正地拋出 `ConnectionError`，這非常困難且不穩定。
    2.  **DIP 重構：**
        * 定義一個 `ISmsProvider` 介面，有 `send_code(phone, code)` 方法。
        * 建立一個 `ConcreteSmsProvider(ISmsProvider)`，其內部去呼叫真正的 `SmsApiClient`。
        * 修改 `RegistrationService`，讓它在建構函式中接收一個 `ISmsProvider` 的實例。
    3.  **提升後的單元測試：** 在測試程式碼中，我們可以建立一個「測試用的假物件」(Mock/Fake Object)，讓它在被呼叫時必定拋出 `ConnectionError`，從而可以簡單、快速、可靠地測試失敗路徑。

#### **思考題 4 解答 (ISP & DIP)**
* **思路提示：** ISP 的核心是為客戶端建立專屬介面。這裡的「客戶端」是不同類型的應用程式。DIP 則要求我們將「設備操作」與「硬體控制」分離。
* **解答與分析：**
    1.  **ISP 應用 - 拆分設備節點：**
        * 建立兩個字元設備節點：`/dev/crypto_bulk`（用於加解密，實現 `read`, `write`, `ioctl`）和 `/dev/hwrng`（用於取亂數，只實現 `read`）。這樣，只想獲取亂數的應用程式，完全不需要知道任何關於 AES 加密的複雜 `ioctl` 命令的存在。
    2.  **DIP 應用 - 驅動內部分層：**
        * **核心模組 (`crypto_accel_core.c`):** 低階模組，負責與硬體 I/O 互動，並提供一組抽象的函式（如 `core_bulk_encrypt`, `core_get_random_bytes`）給上層使用。
        * **介面模組 (`crypto_bulk_dev.c`, `hwrng_dev.c`):** 高階模組，負責實現 `file_operations` 並與 VFS 互動。它們透過呼叫核心模組提供的抽象函式來完成工作，從而將「與 VFS 溝通的介面邏輯」和「與硬體溝通的底層邏輯」分離。

#### **程式練習題 1 解答 (Refactoring a "God Object")**
* **思路提示：** 逐一識別出不同職責：資料庫存取、業務計算、格式化、檔案寫入。為每個職責建立一個專門的類別和抽象介面。
* **解答與分析 (程式碼骨架):**
    ```python
    # 1. 定義抽象介面 (DIP)
    class ISalesRepository: ...
    class IReportFormatter: ...
    class IReportWriter: ...

    # 2. 建立具體實現 (SRP)
    class SqliteSalesRepository(ISalesRepository): ...
    class HtmlReportFormatter(IReportFormatter): ...
    class LocalFileWriter(IReportWriter): ...
        
    # 3. 核心業務邏輯類別 (高階模組)
    class SalesReporter:
        def __init__(self, repo: ISalesRepository, formatter: IReportFormatter, writer: IReportWriter): ...
        def generate(self, start, end, destination): ...

    # 4. 組裝區
    repo = SqliteSalesRepository(...)
    # ...
    reporter = SalesReporter(repo, formatter, writer)
    reporter.generate(...)
    ```

#### **程式練習題 2 解答 (Building a Plugin System)**
* **思路提示：** 核心 `TextAnalyzer` 應該依賴 `ITextPlugin` 介面的「列表」，而不是任何具體的插件。插件的實例化和註冊應該在外部的「組裝區」完成。
* **解答與分析 (程式碼骨架):**
    ```python
    # 1. 抽象介面
    class ITextPlugin(ABC): ...

    # 2. 主程式 (對修改封閉)
    class TextAnalyzer:
        def __init__(self): self._plugins = []
        def register_plugin(self, plugin: ITextPlugin): ...
        def analyze_file(self, filepath: str): ...

    # 3. 具體插件 (對擴展開放)
    class WordCountPlugin(ITextPlugin): ...
    class LineCountPlugin(ITextPlugin): ...

    # 4. 組裝區
    analyzer = TextAnalyzer()
    analyzer.register_plugin(WordCountPlugin())
    analyzer.register_plugin(LineCountPlugin())
    analyzer.analyze_file(...)
    ```

#### **程式練習題 3 解答 (Refactoring a Polling Function)**
* **思路提示：** 這是 C 語言中應用 OCP/DIP 的經典場景。關鍵是定義一個抽象的「處理器」契約（通常用函式指標結構），然後用一個處理器陣列來構成一個可擴展的系統。
* **解答與分析 (重構後的程式碼):**
    ```c
    // 1. 定義抽象契約 (DIP)
    typedef struct {
        const uint32_t status_mask;
        void (*handler_func)(device_t* dev);
    } status_handler_t;

    // 2. 建立一個可擴充的處理器列表 (OCP 的核心)
    static const status_handler_t status_handlers[] = {
        { .status_mask = DATA_READY, .handler_func = process_incoming_data },
        { .status_mask = ERROR_FLAG, .handler_func = log_error_and_reset },
        { .status_mask = TEMP_WARN,  .handler_func = adjust_fan_speed },
    };

    // 3. 重構後的核心輪詢函式 (對修改封閉)
    void poll_device_status_refactored(device_t* dev) {
        uint32_t status = dev->status_reg;
        int num_handlers = sizeof(status_handlers) / sizeof(status_handlers[0]);
        for (int i = 0; i < num_handlers; ++i) {
            if (status & status_handlers[i].status_mask) {
                status_handlers[i].handler_func(dev);
            }
        }
    }
    ```
</details>
