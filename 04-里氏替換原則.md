### 第四章：里氏替換原則 (LSP) — 繼承的契約

里氏替換原則 (Liskov Substitution Principle, LSP) 聽起來像是一個複雜的數學定理，但它的核心思想卻非常直觀，旨在回答一個根本問題：**什麼樣的繼承才是「好」的繼承？**

LSP 為物件導向中的繼承關係建立了一套行為準則。它確保了子類別能夠在不破壞系統原有功能的前提下，真正地「扮演」其父類別的角色。這個原則是構建可靠、可預測軟體系統的關鍵，也是開放封閉原則 (OCP) 能夠安全實施的根本保障。

#### 1. 定義與核心思想

LSP 由電腦科學家 Barbara Liskov 在 1987 年提出，其較為正式的定義是：

> "Let Φ(x) be a property provable about objects x of type T. Then Φ(y) should be true for objects y of type S where S is a subtype of T."
> (如果對於型別 T 的任意物件 x，都有一個可證明的屬性 Φ(x) 成立，那麼對於型別 S 的任意物件 y，其中 S 是 T 的子型別，Φ(y) 也應該成立。)

這個定義非常學術。讓我們用一句更廣為人知、也更易於理解的白話文來詮釋它：

**「在任何使用父類別物件的地方，都應該可以無縫地替換成其子類別的物件，而程式的行為不會產生任何錯誤或異常。」**

換句話說，子類別對父類別的繼承，必須是**行為上 (behavioral)** 的一致，而不僅僅是**語法上 (structural)** 的繼承。子類別可以有自己的新行為，但絕不能改變或違反父類別已經承諾的行為。

一個經典的反問式比喻：如果它看起來像鴨子，叫起來像鴨子，但它需要電池才能工作，那麼它可能繼承錯了父類別。一個需要電池的「玩具鴨」不能無縫替換一隻真正的「鴨子」而不產生問題。

#### 2. 為何重要？違反 LSP 的代價

違反 LSP 的繼承，是一種「虛假的繼承」，它會讓你的程式碼充滿陷阱和意外。

1.  **破壞多態性 (Broken Polymorphism):** 物件導向最大的優勢之一就是多態。違反 LSP 意味著我們無法再信任父類別的契約，導致我們在使用多態時處處碰壁。
2.  **充斥著型別檢查 (Type Checking Proliferation):** 為了避免子類別的「意外行為」，開發者被迫在使用父類別的地方，加入大量的 `if isinstance(obj, ChildClass)` 這樣的檢查。這直接導致了對 OCP 的違反，程式碼變得僵化且難以擴展。
3.  **難以預測的行為 (Unpredictable Behavior):** 你以為你呼叫的是父類別定義的穩定行為，但子類別卻在背後「搞小動作」，拋出新的異常、回傳非預期的值，或者什麼都不做，讓整個系統陷入混亂。
4.  **單元測試困難 (Difficult Unit Testing):** 你無法為一個父類別的模組編寫一套通用的單元測試，因為每個子類別的行為都可能不同，你需要為每個子類別編寫特化的測試案例，違背了測試的初衷。

#### 3. 程式碼實戰：從違規到遵循

LSP 的違規通常很隱晦，讓我們透過兩個經典的範例來揭示它。

##### 範例一 (Python): 長方形與正方形的陷阱

在數學上，正方形是長方形的一種。這個「is-a」關係讓我們很自然地想使用繼承。

* **反面範例 (Bad Practice): 違反父類別行為的子類別**

    ```python
    class Rectangle:
        def __init__(self, width: float, height: float):
            self._width = width
            self._height = height
        @property
        def area(self) -> float:
            return self._width * self._height
        def set_width(self, width: float):
            self._width = width
        def set_height(self, height: float):
            self._height = height

    class Square(Rectangle):
        def __init__(self, size: float):
            super().__init__(size, size)
        # 為了維持「正方形」的特性，重寫了父類別的行為
        def set_width(self, width: float):
            self._width = width
            self._height = width
        def set_height(self, height: float):
            self._width = height
            self._height = height

    # 一個依賴父類別 Rectangle 的函式
    def use_rectangle(rect: Rectangle):
        rect.set_width(5)
        rect.set_height(4)
        # 我們對 Rectangle 的「期望行為」是：設定寬為5，高為4後，面積應該是 20
        expected_area = 5 * 4
        actual_area = rect.area
        print(f"期望面積: {expected_area}, 實際面積: {actual_area}")
        assert actual_area == expected_area

    rect = Rectangle(2, 3)
    print("使用長方形:")
    use_rectangle(rect) # 正常運作

    sq = Square(5)
    print("\n使用正方形:")
    use_rectangle(sq) # 程式崩潰！ AssertionError
    ```

    **問題分析：** `Square` 類別為了維持自己的不變性（邊長相等），改變了父類別 `set_width` 和 `set_height` 方法的行為。`Square` 無法被安全地替換 `Rectangle`，因此這個繼承關係違反了 LSP。

* **正面範例 (Good Practice): 尊重契約或放棄繼承**
    解決方案是建立更通用的抽象（如 `Shape`），或承認兩者行為不同而放棄繼承，改用組合。

##### 範例二 (C): Linux 核心 `file_operations` 的契約精神

Linux 核心的 VFS 架構是 LSP 在 C 語言中最宏大、最真實的體現。

* **角色對應:**
    * **抽象契約 (父類別):** `struct file_operations` 的定義及其文件。
    * **具體實現 (子類別):** 各檔案系統驅動（ext4, Btrfs）或設備驅動提供的 `file_operations` 實例。
    * **客戶端:** VFS 核心層。

* **程式碼模擬與分析**
    我們模擬一個簡化的場景，VFS 依賴 `read` 函式的回傳值（後置條件）契約。

    ```c
    #include <stdio.h>
    #include <errno.h>

    // 抽象契約：定義 file_operations 結構
    // 契約內容 (透過文件和慣例): read 成功回傳讀取字節數, 失敗回傳負的錯誤碼
    struct file_operations {
        int (*read)(char* buf, int size);
    };

    struct file {
        // ... 其他 file 成員
        const struct file_operations* f_op; // 指向具體實現的指標
    };

    // 客戶端：VFS 的簡化邏輯
    void vfs_read(struct file* f, char* buf, int size) {
        if (!f->f_op || !f->f_op->read) return;

        int bytes_read = f->f_op->read(buf, size);
        if (bytes_read < 0) {
            // 客戶端期望負數代表錯誤
            printf("VFS: 偵測到讀取錯誤, 錯誤碼: %d\n", bytes_read);
        } else {
            printf("VFS: 成功讀取 %d 字節\n", bytes_read);
        }
    }

    // --- 正面範例：遵循契約的驅動 ---
    int good_driver_read(char* buf, int size) {
        // ... 成功讀取
        return size; // 回傳讀取的字節數
    }

    // --- 反面範例：違反契約的驅動 ---
    int bad_driver_read(char* buf, int size) {
        // 假設發生了硬體錯誤
        // BUG: 違反了契約，失敗時回傳了 0 而不是負數
        return 0;
    }

    // --- 模擬使用 ---
    int main() {
        struct file_operations good_fops = { .read = good_driver_read };
        struct file_operations bad_fops  = { .read = bad_driver_read };

        struct file good_file = { .f_op = &good_fops };
        struct file bad_file  = { .f_op = &bad_fops };

        char buffer[10];

        printf("測試遵循 LSP 的驅動:\n");
        vfs_read(&good_file, buffer, 10); // VFS 邏輯正確

        printf("\n測試違反 LSP 的驅動:\n");
        vfs_read(&bad_file, buffer, 10);  // VFS 將錯誤(0)解讀為成功讀取0字節，邏輯出錯！
    }
    ```
    **問題分析:** `bad_driver_read` 破壞了 `file_operations` 的後置條件契約。VFS 客戶端在替換使用它時，會錯誤地解讀其回傳值，從而引發潛在的系統錯誤。這完美地展示了**行為不一致**如何破壞系統。

#### 4. 提醒：現實世界中的取捨與權衡
在大型、歷史悠久的 C 專案中，你可能會發現一些函式雖然功能相似，但其錯誤處理方式（回傳值、全域變數設定）卻有微小差異。這通常是歷史演進的結果。這也提醒我們，定義清晰、文檔完備的函式契約是多麼重要。

#### 5. 掌握的跡象：LSP的「品味」

* **程式碼壞味道 (Code Smells):**
    * 子類別中出現空的 override 方法。
    * 子類別的 override 方法中拋出父類別未聲明的異常。
    * 在程式碼中看到 `if (obj instanceof ChildClass)`。
* **思維轉變的體現:**
    * 你會從「is-a」的語意思考，轉向「is-substitutable-for」的行為思考。
    * 你會更加關注父類別（或介面）中每個方法的**前置條件 (Preconditions)** 和 **後置條件 (Postconditions)**。
* **與 AI 協作的進化:**
    * 你會要求 AI：「請檢查這個繼承關係是否違反了 LSP。特別是，子類別的方法是否強化了前置條件，或者弱化了後置條件？」

#### 6. 精通之路：LSP的刻意練習

1.  **一個小練習 (Kata):**
    * 考慮一個 `Bird` 父類別，它有一個 `fly()` 方法。現在，你需要建立一個 `Ostrich`（鴕鳥）子類別。你該如何設計才能不違反 LSP？（提示：這會引導你重新思考 `Bird` 的設計）。
2.  **Code Review 清單:**
    * **[ ] 這個子類別是否改變了父類別方法的預期行為？**
    * **[ ] 如果我把這個子類別物件傳給一個只知道父類別的函式，函式會不會出錯？**
3.  **自我反思問題:**
    * 我真的需要「繼承」嗎？如果只是為了「重用程式碼」，我是否應該考慮使用「組合」？

#### 7. 小結與連結

里氏替換原則是確保物件導向繼承體系穩固的紀律委員。它強迫我們建立在行為上一致的繼承層次，從而讓多態和代碼抽象能夠安全可靠地運作。

* **它是 OCP 的安全帶：** 開放封閉原則 (OCP) 依賴於我們能安全地用新的子類別來擴展系統。LSP 保證了 OCP 的擴展是安全的。
* **它與 ISP 共同作用：** 如果一個父類別介面過於臃腫（違反 ISP），那麼子類別就很難完全實現所有行為，從而更容易違反 LSP。
