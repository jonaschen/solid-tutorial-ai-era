### 第二章：單一職責原則 (SRP) — 專注的力量

單一職責原則 (Single Responsibility Principle, SRP) 是 SOLID 中最基礎、也最常被誤解的一個。它看似簡單，實則深刻地影響著軟體設計的每一個角落。掌握它，是踏出「寫出能動的程式」並邁向「建構健壯的系統」的第一步。本章將帶您徹底理解 SRP 的精髓，並學會如何在不同層次的開發中應用它。

#### 1. 定義與核心思想

Robert C. Martin 對 SRP 的經典定義是：

> "A class should have one, and only one, reason to change."
> (一個類別應該只有一個使其變更的原因。)

許多人第一次看到這個定義時都會感到「似懂非懂」。什麼是「一個原因」？這是一個相當抽象的概念。

為了讓它更具體，Uncle Bob 後來補充了一個更精確的說法：

> "Gather together the things that change for the same reasons. Separate those things that change for different reasons."
> (將因為相同原因而變更的東西聚合在一起。將因為不同原因而變更的東西分開。)

這裡的「原因」，最實際的理解方式是**「一群關心這件事的人或角色 (Actor)」**。一個軟體系統會有多個角色關心它：
* **財務長** 關心營收報表的計算規則。
* **資料庫管理員 (DBA)** 關心資料庫的結構和效能。
* **法務長** 關心隱私政策和資料保存期限。

如果一個類別的程式碼，同時被來自**財務長**的需求和來自**DBA**的需求所驅動修改，那麼這個類別就有了**兩個**變更的原因。它違反了 SRP。

**SRP 的核心思想就是：一個類別（或模組、函式）應該只對一個「角色」負責。**

#### 2. 為何重要？違反 SRP 的代價

當我們違反 SRP，讓一個類別像一把功能過多的瑞士刀時，會付出沉重的代價：

1.  **高耦合 (High Coupling):** 不相關的職責被緊緊綁在一起。修改報表格式的程式碼，卻可能影響到資料庫連線的邏輯。就像想修理瑞士刀上的小剪刀，卻必須把整把刀送修一樣。
2.  **脆弱性 (Fragility):** 這是一個必然的結果。當財務長要求修改報表計算規則時，你修改了程式碼，卻意外地破壞了資料庫的存取邏輯，導致系統在一個意想不到的地方崩潰。
3.  **測試困難 (Difficult to Test):** 如果報表生成、資料庫存取、日誌記錄全都在一個類別裡，為了測試小小的報表格式，你可能需要模擬一個完整的資料庫連線和檔案系統，測試變得異常複雜和緩慢。
4.  **合併衝突 (Merge Conflicts):** 在團隊協作中，這是一個非常實際的痛點。開發者 A 為了財務長的需求修改了報表邏輯，同時開發者 B 為了 DBA 的需求優化了資料庫查詢，他們兩人將會修改同一個檔案，引發痛苦的程式碼合併衝突。

#### 3. 程式碼實戰：從違規到遵循

讓我們透過兩個不同層級的例子，一個使用 Python，一個使用 C，來感受 SRP 的威力。

##### 範例一 (Python): 高階應用程式的職責分離

假設我們在開發一個 Python 應用，需要一個 `Report` 類別。

* **反面範例 (Bad Practice): 一個無所不包的 `Report` 類別**

    ```python
    import json
    import sqlite3

    class Report:
        def __init__(self, title, content):
            self.title = title
            self.content = content

        def get_data_from_db(self, query):
            """職責一：資料庫存取"""
            print(f"從資料庫獲取資料: {query}")
            # conn = sqlite3.connect('my_database.db')
            # ... 執行查詢 ...
            self.content = "從資料庫來的資料" # 假設的資料

        def format_as_json(self):
            """職責二：格式化"""
            print("將報告內容格式化為 JSON")
            report_dict = {
                'title': self.title,
                'content': self.content
            }
            return json.dumps(report_dict)

    # 使用方式
    report = Report("月度銷售報告", "")
    report.get_data_from_db("SELECT * FROM sales")
    json_report = report.format_as_json()
    print(json_report)
    ```

    **問題分析：**
    這個 `Report` 類別有兩個變更原因：
    1.  **資料庫相關的變更：** 如果我們從 SQLite 換成 PostgreSQL，或者資料表結構改變，`get_data_from_db` 就得修改。這是 **DBA** 關心的。
    2.  **報告格式的變更：** 如果客戶要求從 JSON 改成 XML 或 PDF，`format_as_json` 就得修改。這是**客戶或產品經理**關心的。
    這兩個職責被耦合在了一起。

* **正面範例 (Good Practice): 將職責分離**

    我們將其拆分為兩個專注的類別：

    ```python
    import json

    # 職責一：專注於報告的內容與結構
    class Report:
        def __init__(self, title, content):
            self.title = title
            self.content = content

    # 職責二：專注於報告的儲存與讀取
    class ReportRepository:
        def get_report_data(self, query):
            print(f"從資料庫獲取資料: {query}")
            # ... 實際的資料庫操作 ...
            return "從資料庫來的資料"

    # 職責三：專注於報告的呈現
    class JsonReportPresenter:
        def format(self, report):
            print("將報告內容格式化為 JSON")
            report_dict = {
                'title': report.title,
                'content': report.content
            }
            return json.dumps(report_dict)

    # 使用方式 (由一個更高層的協調者來組合)
    repository = ReportRepository()
    presenter = JsonReportPresenter()

    report_content = repository.get_report_data("SELECT * FROM sales")
    report = Report("月度銷售報告", report_content)
    json_presentation = presenter.format(report)
    print(json_presentation)
    ```

    現在，如果資料庫需要變更，我們只需要修改 `ReportRepository`。如果格式需要變更，我們只需要修改 `JsonReportPresenter`（或者新增一個 `XmlReportPresenter`）。`Report` 類別本身變得非常穩定。每個類別都只有一個變更的原因。

##### 範例二 (C): 底層系統的模組職責

在 C 語言這類非物件導向的語言中，SRP 的應用單位通常是**檔案 (file)** 或**模組 (module)**。

* **反面範例 (Bad Practice): 一個混雜的驅動程式檔案 `task_manager.c`**

    想像一個簡單的嵌入式任務管理器 `task_manager.c`，它負責：
    1.  從序列埠 (UART) 接收命令。
    2.  解析命令，決定要執行哪個任務。
    3.  將任務執行狀態寫入 Flash 記憶體作為日誌。

    ```c
    // task_manager.c (反面範例)
    #include <stdio.h>
    #include "uart.h"      // 硬體驅動
    #include "flash.h"     // 硬體驅動
    #include "task_logic.h"// 業務邏輯

    void handle_all_tasks() {
        // 職責一: 讀取硬體
        char command[256];
        uart_read_line(command, sizeof(command));

        // 職責二: 解析與執行業務邏輯
        int task_id = parse_command(command);
        execute_task(task_id);

        // 職責三: 寫入硬體
        char log_message[512];
        sprintf(log_message, "Task %d executed.", task_id);
        flash_write_log(log_message);
    }
    ```
    **問題分析：**
    這個檔案 `task_manager.c` 的變更原因至少有三個：
    1.  **通訊協定變更：** 如果通訊方式從 UART 改成 SPI，`uart_read_line` 相關邏輯要改。
    2.  **任務邏輯變更：** 如果新增或修改任務，`parse_command` 或 `execute_task` 要改。
    3.  **日誌策略變更：** 如果日誌從 Flash 改為寫入網路，`flash_write_log` 要改。

* **正面範例 (Good Practice): 職責分離到不同模組**

    我們將其拆分為三個獨立的 `.c` 檔案，每個檔案負責一項職責。

    `input_handler.c` **(只負責輸入)**
    ```c
    // input_handler.c
    #include "uart.h"
    void get_next_command(char* buffer, int size) {
        uart_read_line(buffer, size);
    }
    ```

    `app_logic.c` **(只負責應用程式邏輯)**
    ```c
    // app_logic.c
    #include "task_logic.h"
    void process_command(const char* command) {
        int task_id = parse_command(command);
        execute_task(task_id);
        // 它不知道命令從哪來，也不知道結果要記到哪去
    }
    ```

    `logging.c` **(只負責日誌)**
    ```c
    // logging.c
    #include <stdio.h>
    #include "flash.h"
    void log_task_execution(int task_id) {
        char log_message[512];
        sprintf(log_message, "Task %d executed.", task_id);
        flash_write_log(log_message);
    }
    ```

    `main.c` **(作為協調者)**
    ```c
    // main.c
    #include "input_handler.h"
    #include "app_logic.h"
    #include "logging.h"

    int main() {
        while(1) {
            char command[256];
            get_next_command(command, sizeof(command)); // 從輸入模組拿命令
            process_command(command);                  // 交給邏輯模組處理
            log_task_execution(get_last_task_id());    // 讓日誌模組記錄
        }
        return 0;
    }
    ```
    現在，`main.c` 負責協調，但它本身不包含任何具體的硬體或業務邏輯。每個 `.c` 檔案都有了自己清晰、單一的職責，修改其中一個不會輕易影響到其他模組。這就是 SRP 在 C 語言中的體現。

#### 4. 掌握的跡象：SRP的「品味」

當你開始內化 SRP 時，你會培養出一種設計上的「品味」或直覺。

* **程式碼壞味道 (Code Smells):**
    * **冗長的 `import` / `#include` 列表：** 當你看到一個 Python 類別同時 `import database` 和 `import requests`，或一個 C 檔案同時 `#include <linux/netdevice.h>` 和 `#include <linux/fs.h>`，這就是一個強烈警訊，表示它可能承擔了網路和檔案系統兩種職責。
    * **通用的命名：** 類別或檔案被命名為 `Manager`, `Utils`, `Helper`，通常意味著它是一個「大雜燴」，裡面放了各種不相關的函式。
    * **難以命名：** 當你很難為一個類別或函式取一個精確的名字時，通常是因為它做了不止一件事。

* **思維轉變的體現:**
    * 你不再問「這段程式碼要放在哪裡？」，而是問「哪個物件或模組應該**擁有**這個職責？」
    * 你看到一個巨大的類別時，會下意識地開始在腦中將它的方法分組，思考它們分別服務於哪個「角色」。

* **與 AI 協作的進化:**
    * 你的指令會從「幫我寫個使用者管理類別」變成更精確的：「幫我寫一個 `UserAuthenticator` 類別，它唯一的職責是驗證使用者的密碼，它 sollte接收使用者名稱和密碼，返回布林值。不要包含任何資料庫讀取或 Session 管理的程式碼。」

#### 5. 精通之路：SRP的刻意練習

1.  **一個小練習 (Kata):**
    * 審視你手邊專案中的一個 `User` 或 `Order` 類別。幾乎可以肯定，它包含了太多職責。拿出一張紙，列出這個類別中所有 `public` 方法。嘗試將這些方法根據「關心的角色」（如：身份驗證、資料庫持久化、訂單計算、發票生成）進行分組。看看你能將一個大類別拆分成幾個更小的、職責單一的類別。

2.  **Code Review 清單:**
    * **[ ] 這個類別/檔案能用一句話描述清楚它的職責嗎？（試著不要用「和」或「與」）**
    * **[ ] 這個類別的變更原因有幾個？如果UI格式要改，或者資料庫要換，或者業務規則要調，是否都需要動這一個檔案？**
    * **[ ] 這個類別的所有方法，是否都服務於同一個高層次的目標？**

3.  **自我反思問題:**
    * 我剛剛寫的這個類別，它依賴的模組是否都屬於同一個領域？
    * 如果半年後，一個完全不熟這個專案的同事要來修改它，他能快速理解這個類別是做什麼的嗎？

#### 6. 小結與連結

單一職責原則是 SOLID 中最重要也最基礎的原則。它強迫我們在動手寫程式碼之前，先進行思考和分解，將複雜的問題拆解成一個個職責單一、易於管理的小單元。

SRP 與其他原則緊密相連：
* **它是實現「開放封閉原則 (OCP)」的基礎。** 因為只有當一個類別職責單一時，你才可能在不修改它的情況下，透過擴展（例如新增一個職責相似的兄弟類別）來增加新功能。
* **它能引導你走向「介面隔離原則 (ISP)」。** 當你將大類別拆分成多個小類別時，每個小類別的介面自然也會變得更小、更專注。

遵循 SRP，就像是為你的軟體大廈打下最堅實的地基。雖然初期會花費更多時間進行設計，但它會在未來的維護、擴展和測試階段，為你省下無數的時間和精力。
